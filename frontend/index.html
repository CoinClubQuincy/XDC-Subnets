<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Siftr Invoice → MetaMask / Web3Auth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">
   <script src="app.js"></script><link rel="stylesheet" href="style.css">
  <!-- Web3Auth Modal SDK (v10.x UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@web3auth/modal@10.3.0/dist/modal.umd.min.js"></script>
  <!-- Note: From v10, you typically don't need to load OpenLogin adapter separately; it's bundled in Modal. -->
</head>
<body class="with-topbar">
  <div class="topbar" id="topbar">
    <div class="inner">
      <div class="brand">
        <img class="logo" src="sifter-logo.png" alt="SFTR" />
        <span>Siftr Invoice Credit</span>
      </div>
      <div class="top-actions">
        <span id="top-balance" class="chip">Balance: —</span>
        <span id="top-address" class="chip">Account: —</span>
        <button id="top-connect" class="top-btn primary">Connect Account</button>
        <button id="top-connect-web3auth" class="top-btn">Connect Web3Auth</button>
      </div>
    </div>
  </div>
  <div class="wrap">
    <!-- Invoices List -->
    <section id="page-list" class="card">
      <h1>Invoices</h1>
      <h2>Select an invoice to pay</h2>
      <div class="tabs">
        <div id="tab-unpaid" class="tab active">Unpaid</div>
        <div id="tab-paid" class="tab">Paid</div>
      </div>
      <ul id="invoice-list" class="list"></ul>
      <div id="no-items" class="small muted" style="display:none; margin-top:6px;">No items to display.</div>
      <div class="meta">This is a demo list with fixed amounts & IDs. Selecting one opens the invoice drawer.</div>
    </section>
    <div id="drawer-backdrop" class="backdrop hidden"></div>
    <div id="drawer" class="drawer">
      <div class="panel card">
        <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom:8px;">
          <div class="muted">Invoice Details</div>
          <button id="btn-close" title="Close" aria-label="Close">✕</button>
        </div>
    <!-- Invoice Page -->
    <section id="page-invoice">
      <h1 style="display:flex; align-items:center; gap:10px;">
        <img class="logo lg" src="sifter-logo.png" alt="SFTR" />
        Invoice
      </h1>
      <h2>Pay with SFTR via Wallet (MetaMask or Web3Auth)</h2>
      <div id="chosen-invoice" class="small" style="margin-bottom:8px;"></div>

      <div class="row">
        <div>
          <label>Amount</label>
          <input id="amount" type="text" inputmode="decimal" placeholder="e.g. 12.50" />
        </div>
        <div>
          <label>Currency (symbol)</label>
          <input id="symbol" type="text" value="SFTR" />
        </div>
      </div>
      <div id="fiatSummary" class="fiatline"></div>

      <label>Invoice ID (optional)</label>
      <input id="invoiceId" type="text" placeholder="e.g. INV-2025-0001" />

      <div class="divider"></div>

      <div class="row">
        <div>
          <label>Payer Wallet</label>
          <input id="account" type="text" readonly placeholder="Not connected" />
        </div>
      </div>

      <div class="btns">
        <button id="btn-connect">Connect MetaMask</button>
        <button id="btn-connect-web3auth" title="Sign in with Web3Auth">Connect Web3Auth</button>
        <button id="btn-pay" class="primary" disabled>Pay Invoice</button>
      </div>

      <div id="status" class="meta"></div>
      <div id="alert" class="notice hidden"></div>
    </section>

    <!-- Confirm Page -->
    <section id="page-confirm" class="hidden">
      <h1>Confirm Payment</h1>
      <div id="confirm-body" class="meta"></div>
      <div class="btns">
        <button id="btn-cancel">Back</button>
        <button id="btn-confirm" class="primary">Confirm &amp; Sign</button>
      </div>
      <div id="confirm-status" class="meta"></div>
    </section>
    <!-- Result Page -->
    <section id="page-result" class="hidden">
      <h1 id="result-title">Payment Result</h1>
      <div id="result-body" class="meta"></div>
      <div class="txlink meta" id="txlink"></div>
      <div class="btns">
        <button id="btn-back">Back to Invoice</button>
      </div>
    </section>
      </div>
    </div>
  </div>

  <!-- Ethers.js (v5) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" integrity="sha256-pmKTpqK7Te4GGmhhK+C+PFwKt+QGirjZiko1e69mTHM=" crossorigin="anonymous"></script>
  <script>
    /**
     * Web3Auth Setup Checklist:
     * 1) Create a project at https://dashboard.web3auth.io and copy the Client ID.
     * 2) Whitelist origins: add your dev URL (http://127.0.0.1:xxxx or http://localhost:xxxx) and production domains.
     * 3) Set CONFIG.WEB3AUTH_CLIENT_ID to your Client ID.
     * 4) Set CONFIG.EXPECTED_CHAIN_ID_HEX (e.g., '0x539' for Ganache; '0x32' XDC Mainnet, '0x33' XDC Apothem).
     * 5) Update CONFIG.WEB3AUTH_CHAIN.rpcTarget to your RPC endpoint (Ganache now; XDC later).
     * 6) Deploy: use HTTPS in production (Web3Auth blocks non-secure origins except localhost).
     * Notes:
     * - Web3Auth provides an EIP-1193 provider; the rest of your ethers.js logic is unchanged.
     * - You can remove MetaMask later without refactoring your pay/approve flows.
     */
    // ============
    // CONFIG—EDIT THESE
    // ============
    // Demo invoice data (fixed for now)
    const DEMO_INVOICES = [
      { id: "INV-2025-0001", amount: "12.50", symbol: "SFTR" },
      { id: "INV-2025-0002", amount: "49.99", symbol: "SFTR" },
      { id: "INV-2025-0003", amount: "5.00",   symbol: "SFTR" },
      { id: "INV-2025-0004", amount: "199.00", symbol: "SFTR" },
    ];
    const PAID_INVOICES = [];
    let showPaid = false; // false = show unpaid; true = show paid
    const PRICE_USD_PER_SFTR = 1.25; // fixed price for display
    function usdFor(amountStr) {
      const a = parseFloat((amountStr || "0").replace(/,/g, "").trim());
      const usd = isNaN(a) ? 0 : a * PRICE_USD_PER_SFTR;
      return `≈ $${usd.toFixed(2)}`;
    }

    function renderInvoiceList() {
      const ul = document.getElementById("invoice-list");
      const noItems = document.getElementById("no-items");
      ul.innerHTML = "";
      const source = showPaid ? PAID_INVOICES : DEMO_INVOICES;

      if (source.length === 0) {
        noItems.style.display = "block";
        return;
      } else {
        noItems.style.display = "none";
      }

      source.forEach((inv) => {
        const li = document.createElement("li");
        li.className = "rowline" + (showPaid ? "" : " clicky");
        li.innerHTML = `
          <div class="left">
            <img class="logo" src="sifter-logo.png" alt="SFTR" />
            <div>
              <div><b>${inv.amount} ${inv.symbol}</b></div>
              <div class="small">${inv.id}</div>
              ${inv.memo ? `<div class="small muted">Memo: ${inv.memo}</div>` : ""}
              ${inv.txHash ? `<div class="small txlink">Tx: <span class="kbd">${inv.txHash.slice(0,10)}…</span></div>` : ""}
            </div>
          </div>
          <div class="muted" data-usd>${usdFor(inv.amount)}</div>
        `;
        if (!showPaid) {
          li.addEventListener("click", () => selectInvoice(inv));
        }
        ul.appendChild(li);
      });
    }
    function shortAddr(a) { return a ? a.slice(0,6) + "…" + a.slice(-4) : "—"; }

    async function refreshTopbar() {
      try {
        const addr = accounts?.[0] || "";
        $("top-address").textContent = addr ? `Account: ${shortAddr(addr)}` : "Account: —";

        let balStr = "—";
        if (addr && erc20) {
          const bal = await erc20.balanceOf(addr);
          balStr = `${fmtUnits(bal)} ${CONFIG.TOKEN_SYMBOL || "SFTR"}`;
        }
        $("top-balance").textContent = `Balance: ${balStr}`;

        $("top-connect").textContent = addr ? "Connected" : "Connect Account";
      } catch (e) {
        // Non-fatal
      }
    }

    const CONFIG = {
      // Chain you expect (helps prevent mis-sends). Set null to skip enforcing.
      EXPECTED_CHAIN_ID_HEX: "0x539", // Ganache; XDC Mainnet=0x32, Apothem=0x33
      // Which provider should this app prefer on load? 'web3auth' or 'metamask'
      DEFAULT_PROVIDER: 'web3auth',

      // Address of your payment contract that ultimately receives the ERC-20.
      PAYMENT_CONTRACT: "0x50bDa728b919D7854cdbffC94c7d2ADa188630ED",

      // The ERC-20 token contract the invoice is denominated in.
      TOKEN_CONTRACT: "0x396ee78f55f3d95442257fd14A9d60Dbe46C233d",

      // Human symbol & decimals (used for display + parsing). Decimals MUST match your token.
      TOKEN_SYMBOL: "SFTR",
      TOKEN_DECIMALS: 18,

      // Do we need an explicit approval step? (true for transferFrom-based contracts)
      REQUIRE_APPROVAL: true,

      // --- Payment contract ABI & method ---
      // Replace with your actual ABI + method. Below is a minimal example for:
      // function pay(uint256 amount, string memo) external;
      PAYMENT_ABI: [
        "function pay(uint256 amount, string memo) external",
        "event PaymentReceived(address indexed payer, uint256 amount, string memo)"
      ],

      // If your method signature differs, adapt this builder.
      // It must return: { method: string, args: any[] }
      PAY_FUNCTION_ARGS: (amountWei, memo) => ({
        method: "pay",
        args: [amountWei, memo]
      }),

      // Minimal ERC-20 ABI
      ERC20_ABI: [
        "function decimals() view returns (uint8)",
        "function symbol() view returns (string)",
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address owner, address spender) view returns (uint256)",
        "function approve(address spender, uint256 amount) returns (bool)"
      ],

      // Optional block explorer base (for tx links). Example: "https://polygonscan.com/tx/"
      EXPLORER_TX_BASE: "", // leave blank if unknown

      // --- Web3Auth ---
      // Get a Client ID from https://dashboard.web3auth.io and paste it here.
      WEB3AUTH_CLIENT_ID: "BA3_NpnvvlMtl2LcPM2KCWoQ0QY9GIQNcTDwF3LDHffofkW3sn_ZLXT-k-TI5K1JO1TTMsonmMcBniTWU87EHNQ",
      // Chain config for Web3Auth (defaults are fine for local dev; adjust for XDC)
      WEB3AUTH_CHAIN: {
        chainNamespace: "eip155",
        chainId: null,              // we auto-fill from EXPECTED_CHAIN_ID_HEX; leave null
        rpcTarget: "http://127.0.0.1:8545",   // change to your real RPC when ready
        displayName: "Local Dev",
        blockExplorer: "",          // optional
        ticker: "SFTR",
        tickerName: "Siftr",
        logo: "sifter-logo.png"
      },
      // Web3Auth v10 network for dev (change to SAPPHIRE_MAINNET for prod)
      WEB3AUTH_NETWORK: 'SAPPHIRE_DEVNET'
    };

    // ============
    // Helpers
    // ============
    const $ = (id) => document.getElementById(id);
    const show = (el) => el.classList.remove("hidden");
    const hide = (el) => el.classList.add("hidden");

    function toBytes32(str) {
      // simple hash→bytes32 if string is longer; otherwise pad
      const hex = ethers.utils.id(str || ""); // keccak256("...") -> bytes32
      return hex;
    }

    function toUnits(amountStr, decimals) {
      // tolerate commas & spaces
      const clean = (amountStr || "").replace(/,/g, "").trim();
      return ethers.utils.parseUnits(clean || "0", decimals);
    }

    function fmtUnits(bn, decimals = CONFIG.TOKEN_DECIMALS) {
      try { return ethers.utils.formatUnits(bn || 0, decimals); }
      catch { return "0"; }
    }

    function setStatus(msg) { $("status").textContent = msg || ""; }
    function setAlert(msg, ok = true) {
      const el = $("alert");
      el.textContent = msg || "";
      el.className = "notice " + (ok ? "ok" : "bad");
      if (msg) show(el); else hide(el);
    }

    function prettyError(err) {
      const code = err?.code || err?.data?.code;
      if (code === 4001 || /User rejected the request/i.test(err?.message || "")) {
        return "Action was canceled. Please approve the request in your wallet to continue.";
      }
      return err?.data?.message || err?.reason || err?.message || String(err);
    }

    function updateFiatLine() {
      const amt = $("amount").value;
      const sym = $("symbol").value || CONFIG.TOKEN_SYMBOL || "SFTR";
      $("fiatSummary").textContent = amt ? `${amt} ${sym} · ${usdFor(amt)}` : "";
    }

    // Drawer helpers
    function openDrawer() {
      $("drawer").classList.add("open");
      $("drawer-backdrop").classList.add("show");
      $("drawer-backdrop").classList.remove("hidden");
    }
    function closeDrawer() {
      $("drawer").classList.remove("open");
      $("drawer-backdrop").classList.remove("show");
      // leave element in DOM but hide for a11y
      $("drawer-backdrop").classList.add("hidden");
      // default to showing the invoice form (not result) when closing
      show($("page-invoice"));
      hide($("page-result"));
    }
    function showPage(sectionId) {
      ["page-invoice","page-confirm","page-result"].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (id === sectionId) { el.classList.remove("hidden"); }
        else { el.classList.add("hidden"); }
      });
      openDrawer();
    }

    function selectInvoice(inv) {
      // Prefill the invoice form
      $("amount").value = inv.amount;
      $("symbol").value = inv.symbol;
      $("invoiceId").value = inv.id;
      $("chosen-invoice").textContent = `Selected: ${inv.id} · ${inv.amount} ${inv.symbol}`;
      selectedInvoice = inv;
      updateFiatLine();
      // Open drawer with invoice form visible
      show($("page-invoice"));
      hide($("page-result"));
      openDrawer();
    }

    // ============
    // App state
    // ============
    let provider, signer, accounts, chainId;
    let erc20, payContract;
    let selectedInvoice = null;
    let pendingPayment = null; // { amountWei, amountStr, memo }

    // --- Web3Auth state ---
    let web3auth = null;
    let web3authProvider = null;
    let web3authInitPromise = null;
    let web3authReady = false;

    async function initWeb3Auth() {
      // If already initializing/initialized, return the same promise
      if (web3authInitPromise) return web3authInitPromise;

      web3authInitPromise = (async () => {
        try {
          const W3A = window.web3auth || window.Web3Auth;
          if (!W3A || typeof W3A.Web3Auth !== 'function') {
            console.warn('Web3Auth SDK not loaded (check CDN).');
            setAlert('Web3Auth SDK not loaded. Check CDN script tag.', false);
            return;
          }
          if (!CONFIG.WEB3AUTH_CLIENT_ID || CONFIG.WEB3AUTH_CLIENT_ID.startsWith('REPLACE_')) {
            console.warn('Web3Auth clientId missing. Set CONFIG.WEB3AUTH_CLIENT_ID from dashboard.web3auth.io');
            setAlert('Web3Auth Client ID missing. Add it to CONFIG.WEB3AUTH_CLIENT_ID.', false);
          }

          // v10 unified PnP API
          const { Web3Auth, WEB3AUTH_NETWORK, CHAIN_NAMESPACES } = W3A;

          // If you want to force a local dev chain (e.g., 0x539) during development, you can still pass chainConfig.
          // Otherwise, chains should be configured on the Web3Auth Dashboard (recommended in v10).
          const maybeChainConfig = (CONFIG.WEB3AUTH_CHAIN && (CONFIG.WEB3AUTH_CHAIN.chainId || CONFIG.EXPECTED_CHAIN_ID_HEX)) ? {
            chainNamespace: CHAIN_NAMESPACES.EIP155,
            chainId: CONFIG.WEB3AUTH_CHAIN.chainId || CONFIG.EXPECTED_CHAIN_ID_HEX,
            rpcTarget: CONFIG.WEB3AUTH_CHAIN.rpcTarget,
            displayName: CONFIG.WEB3AUTH_CHAIN.displayName,
            blockExplorerUrl: CONFIG.WEB3AUTH_CHAIN.blockExplorer,
            ticker: CONFIG.WEB3AUTH_CHAIN.ticker,
            tickerName: CONFIG.WEB3AUTH_CHAIN.tickerName,
            logo: CONFIG.WEB3AUTH_CHAIN.logo
          } : undefined;

          web3auth = new Web3Auth({
            clientId: CONFIG.WEB3AUTH_CLIENT_ID,
            web3AuthNetwork: WEB3AUTH_NETWORK[CONFIG.WEB3AUTH_NETWORK] || WEB3AUTH_NETWORK.SAPPHIRE_DEVNET,
            ...(maybeChainConfig ? { chainConfig: maybeChainConfig } : {}) ,
            uiConfig: {
              appName: 'Siftr Invoice',
              appLogo: 'sifter-logo.png',
              theme: 'dark'
            }
          });

          // From v10, just call init(); modal is mounted internally.
          await web3auth.init();
          web3authReady = true;

          // If user had an active session, provider will exist
          if (web3auth.provider) {
            try {
              await connectWeb3Auth(true);
            } catch (e) {
              console.warn("Silent Web3Auth connect failed:", e);
            }
          }
        } catch (e) {
          console.warn("Web3Auth init failed:", e);
          setAlert(`Web3Auth init failed: ${e?.message || e}`, false);
        }
      })();

      return web3authInitPromise;
    }

    async function connectWeb3Auth(silent = false) {
      try {
        // Ensure init is complete (or at least awaited once)
        await initWeb3Auth();
        if (!web3auth) throw new Error('Web3Auth not initialized.');
        // v10: init() already mounted the modal. If no session, connect() will open it.
        if (!web3auth.provider) {
          web3authProvider = await web3auth.connect();
        } else {
          web3authProvider = web3auth.provider;
        }
        provider = new ethers.providers.Web3Provider(web3authProvider, "any");
        signer = provider.getSigner();
        accounts = await provider.listAccounts();
        chainId = await provider.send("eth_chainId", []);
        $("account").value = accounts[0] || "";

        if (CONFIG.EXPECTED_CHAIN_ID_HEX && chainId !== CONFIG.EXPECTED_CHAIN_ID_HEX) {
          setAlert(`Wrong network (chainId ${chainId}). Please switch to ${CONFIG.EXPECTED_CHAIN_ID_HEX}.`, false);
        } else {
          setAlert("");
        }

        erc20 = new ethers.Contract(CONFIG.TOKEN_CONTRACT, CONFIG.ERC20_ABI, signer);
        payContract = new ethers.Contract(CONFIG.PAYMENT_CONTRACT, CONFIG.PAYMENT_ABI, signer);

        try {
          const dec = await erc20.decimals();
          await erc20.symbol().catch(() => null);
          $("symbol").value = CONFIG.TOKEN_SYMBOL;
          if (dec != CONFIG.TOKEN_DECIMALS) {
            setAlert(`Warning: token decimals on-chain (${dec}) differ from CONFIG (${CONFIG.TOKEN_DECIMALS}).`, false);
          }
        } catch {}

        $("btn-pay").disabled = false;
        setStatus("Wallet connected (Web3Auth).");
        document.body.classList.add("with-topbar");
        await refreshTopbar();

        // Wire Web3Auth provider events
        web3authProvider?.on?.("accountsChanged", () => location.reload());
        web3authProvider?.on?.("chainChanged", () => location.reload());
      } catch (err) {
        if (!silent) {
          console.error(err);
          setAlert(`Web3Auth error: ${prettyError(err)}`, false);
        }
      }
    }

    async function logoutWeb3Auth() {
      try {
        if (web3auth) {
          await web3auth.logout();
          web3authProvider = null;
        }
        // Clear only if current provider is web3auth
        // (Keeping MetaMask session intact.)
      } catch (e) {
        console.warn("Web3Auth logout failed:", e);
      }
    }

    async function ensureProvider() {
      if (!window.ethereum) {
        throw new Error("MetaMask not found. Please install the extension.");
      }
      provider = new ethers.providers.Web3Provider(window.ethereum, "any");
      return provider;
    }

    async function connect() {
      await ensureProvider();
      accounts = await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      chainId = await provider.send("eth_chainId", []);
      $("account").value = accounts[0] || "";
      if (CONFIG.EXPECTED_CHAIN_ID_HEX && chainId !== CONFIG.EXPECTED_CHAIN_ID_HEX) {
        setAlert(`Wrong network (chainId ${chainId}). Please switch to ${CONFIG.EXPECTED_CHAIN_ID_HEX}.`, false);
      } else {
        setAlert("");
      }

      erc20 = new ethers.Contract(CONFIG.TOKEN_CONTRACT, CONFIG.ERC20_ABI, signer);
      payContract = new ethers.Contract(CONFIG.PAYMENT_CONTRACT, CONFIG.PAYMENT_ABI, signer);

      // Optional sanity: try to fetch decimals/symbol
      try {
        const dec = await erc20.decimals();
        await erc20.symbol().catch(() => null); // probe, ignore value
        $("symbol").value = CONFIG.TOKEN_SYMBOL; // stick with requested display symbol
        if (dec != CONFIG.TOKEN_DECIMALS) {
          setAlert(`Warning: token decimals on-chain (${dec}) differ from CONFIG (${CONFIG.TOKEN_DECIMALS}).`, false);
        }
      } catch (e) {
        // Non-fatal if token is proxied or ABI trimmed
      }

      $("btn-pay").disabled = false;
      setStatus("Wallet connected.");
      document.body.classList.add("with-topbar");
      await refreshTopbar();
    }

    async function pay() {
      setAlert(""); setStatus("");
      $("btn-pay").disabled = true;

      try {
        if (!signer) await connect();

        const amountStr = $("amount").value;
        const amt = toUnits(amountStr, CONFIG.TOKEN_DECIMALS);
        if (amt.lte(0)) throw new Error("Amount must be greater than 0.");

        const from = await signer.getAddress();
        const invoiceIdStr = $("invoiceId").value.trim();
        const memo = invoiceIdStr || `invoice-${Date.now()}`;

        // Store for the confirm step
        pendingPayment = { amountWei: amt, amountStr, memo };

        // Confirmation summary
        $("confirm-body").innerHTML =
          `You're about to pay <b>${amountStr} ${$("symbol").value}</b> (${usdFor(amountStr)})<br>
           From <span class="kbd">${from}</span><br>
           To <span class="kbd">${CONFIG.PAYMENT_CONTRACT}</span><br>
           Memo <span class="kbd">${memo}</span>`;

        $("confirm-status").textContent = "";
        $("btn-confirm").disabled = false;

        // Show confirm page
        showPage("page-confirm");
      } catch (err) {
        console.error(err);
        setAlert(`Error: ${prettyError(err)}`, false);
        $("btn-pay").disabled = false;
      }
    }

    async function confirmAndSend() {
      try {
        $("btn-confirm").disabled = true;
        $("confirm-status").textContent = "Preparing transaction...";

        if (!pendingPayment) throw new Error("Nothing to submit. Please restart the payment.");

        const from = await signer.getAddress();
        const { amountWei, amountStr, memo } = pendingPayment;

        // Approval if required
        if (CONFIG.REQUIRE_APPROVAL) {
          $("confirm-status").textContent = "Checking allowance...";
          const currentAllowance = await erc20.allowance(from, CONFIG.PAYMENT_CONTRACT);
          if (currentAllowance.lt(amountWei)) {
            $("confirm-status").textContent = "Sending approval...";
            const txA = await erc20.approve(CONFIG.PAYMENT_CONTRACT, amountWei);
            await txA.wait();
            $("confirm-status").textContent = "Approval confirmed.";
          } else {
            $("confirm-status").textContent = "Allowance sufficient; skipping approval.";
          }
        }

        // Send payment
        const { method, args } = CONFIG.PAY_FUNCTION_ARGS(amountWei, memo);
        $("confirm-status").textContent = "Sending payment...";
        const tx = await payContract[method](...args);
        const receipt = await tx.wait();
        const txHash = receipt?.transactionHash || tx?.hash || "";

        // Transaction complete → show result
        $("result-title").textContent = "✅ Transaction Complete";
        $("result-body").innerHTML =
          `Paid <span class="kbd">${$("symbol").value}</span> <b>${amountStr}</b> (${usdFor(amountStr)}).<br>
          From <span class="kbd">${from}</span> to <span class="kbd">${CONFIG.PAYMENT_CONTRACT}</span>.<br>
          Memo <span class="kbd">${memo}</span>`;
        if (txHash && CONFIG.EXPLORER_TX_BASE) {
          $("txlink").innerHTML = `Tx: <a href="${CONFIG.EXPLORER_TX_BASE}${txHash}" target="_blank" rel="noreferrer">${txHash}</a>`;
          show($("txlink"));
        } else {
          $("txlink").innerHTML = "";
          hide($("txlink"));
        }
        showPage("page-result");

        // Remove from unpaid and add to paid
        if (selectedInvoice) {
          const idx = DEMO_INVOICES.findIndex(x => x.id === selectedInvoice.id);
          if (idx >= 0) {
            const paid = { ...DEMO_INVOICES[idx], memo, txHash };
            DEMO_INVOICES.splice(idx, 1);
            PAID_INVOICES.unshift(paid);
          }
          renderInvoiceList();
        }

        // Refresh topbar balance
        await refreshTopbar();

        // Reset pending state
        pendingPayment = null;

        // Small pause, then back to main list (show unpaid list by default)
        setTimeout(() => {
          showPaid = false;
          updateTabsUI();
          renderInvoiceList();
          closeDrawer();
          $("btn-pay").disabled = false;
          setStatus("");
          setAlert("");
        }, 1200);
      } catch (err) {
        console.error(err);
        $("confirm-status").textContent = "";
        setAlert(`Error: ${prettyError(err)}`, false);
        $("btn-confirm").disabled = false;
      }
    }
    function updateTabsUI() {
      const u = $("tab-unpaid"), p = $("tab-paid");
      if (showPaid) {
        u.classList.remove("active"); p.classList.add("active");
        $("page-list").querySelector("h1").textContent = "Paid Invoices";
        $("page-list").querySelector("h2").textContent = "Review completed payments";
      } else {
        p.classList.remove("active"); u.classList.add("active");
        $("page-list").querySelector("h1").textContent = "Invoices";
        $("page-list").querySelector("h2").textContent = "Select an invoice to pay";
      }
    }


    function switchPage(toResult, { title = "", body = "", txHash = "" } = {}) {
      if (toResult) {
        $("result-title").textContent = title || "Payment Result";
        $("result-body").innerHTML = body || "";
        const linkEl = $("txlink");
        if (txHash && CONFIG.EXPLORER_TX_BASE) {
          linkEl.innerHTML = `Tx: <a href="${CONFIG.EXPLORER_TX_BASE}${txHash}" target="_blank" rel="noreferrer">${txHash}</a>`;
          show(linkEl);
        } else {
          linkEl.innerHTML = "";
          hide(linkEl);
        }
        hide($("page-invoice"));
        show($("page-result"));
        openDrawer();
      } else {
        show($("page-invoice"));
        hide($("page-result"));
        openDrawer();
      }
    }

    // ============
    // Wire up UI
    // ============
    $("btn-connect").addEventListener("click", connect);
    $("btn-pay").addEventListener("click", pay);
    $("btn-confirm").addEventListener("click", confirmAndSend);
    $("btn-cancel").addEventListener("click", () => showPage("page-invoice"));
    $("btn-back").addEventListener("click", () => showPage("page-invoice"));
    $("btn-close").addEventListener("click", closeDrawer);
    $("drawer-backdrop").addEventListener("click", closeDrawer);
    $("amount").addEventListener("input", updateFiatLine);
    $("symbol").addEventListener("input", updateFiatLine);
    $("tab-unpaid").addEventListener("click", () => { showPaid = false; updateTabsUI(); renderInvoiceList(); });
    $("tab-paid").addEventListener("click", () => { showPaid = true; updateTabsUI(); renderInvoiceList(); });
    $("top-connect").addEventListener("click", connect);
    $("btn-connect-web3auth").addEventListener("click", async () => {
      await initWeb3Auth();
      if (!CONFIG.WEB3AUTH_CLIENT_ID || CONFIG.WEB3AUTH_CLIENT_ID.startsWith("REPLACE_")) {
        setAlert("Add your Web3Auth Client ID to CONFIG.WEB3AUTH_CLIENT_ID.", false);
        return;
      }
      connectWeb3Auth(false);
    });
    $("top-connect-web3auth").addEventListener("click", async () => {
      await initWeb3Auth();
      if (!CONFIG.WEB3AUTH_CLIENT_ID || CONFIG.WEB3AUTH_CLIENT_ID.startsWith("REPLACE_")) {
        setAlert("Add your Web3Auth Client ID to CONFIG.WEB3AUTH_CLIENT_ID.", false);
        return;
      }
      connectWeb3Auth(false);
    });

    // Initialize Web3Auth (non-blocking, early)
    initWeb3Auth();

    // Auto-connect if already authorized (SILENT; no prompts)
    (async function autoConnectIfAuthorized() {
      try {
        // Only attempt MetaMask silent attach if it's the preferred default
        if (CONFIG.DEFAULT_PROVIDER === 'metamask' && window.ethereum) {
          const prov = await ensureProvider();
          // eth_accounts is silent and returns [] if not previously authorized
          const accs = await prov.send("eth_accounts", []);
          if (accs && accs.length) {
            provider = prov;
            signer = provider.getSigner();
            accounts = accs;
            chainId = await provider.send("eth_chainId", []);
            $("account").value = accounts[0] || "";

            erc20 = new ethers.Contract(CONFIG.TOKEN_CONTRACT, CONFIG.ERC20_ABI, signer);
            payContract = new ethers.Contract(CONFIG.PAYMENT_CONTRACT, CONFIG.PAYMENT_ABI, signer);
            document.body.classList.add("with-topbar");
            await refreshTopbar();
            return; // done
          }
        }
        // Otherwise, just render the topbar in a neutral state
        document.body.classList.add("with-topbar");
        await refreshTopbar();
        // If Web3Auth has a cached session, initWeb3Auth() will set it up.
      } catch {
        // ignore; stay neutral
        document.body.classList.add("with-topbar");
      }
    })();


    renderInvoiceList();
    updateFiatLine();
    updateTabsUI();

    // Autofill from URL params (?amount=12.5&symbol=USDC&invoice=INV-1)
    (function initFromQuery() {
      const q = new URLSearchParams(location.search);
      if (q.has("amount")) $("amount").value = q.get("amount");
      if (q.has("symbol")) $("symbol").value = q.get("symbol");
      if (q.has("invoice")) $("invoiceId").value = q.get("invoice");
    })();

    // MetaMask chain/account changes
    if (CONFIG.DEFAULT_PROVIDER === 'metamask' && window.ethereum) {
      window.ethereum.on?.("accountsChanged", () => location.reload());
      window.ethereum.on?.("chainChanged", () => location.reload());
    }
  </script>
</body>
</html>